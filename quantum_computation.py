# -*- coding: utf-8 -*-
"""Quantum_computation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CXKjJ2nw3uJ_xiOXE5A-P_ZWSYb4O4gf
"""

!pip install qiskit

import qiskit



import pickle


with open("/content/data_bead_HPPH.pkl", "rb") as f:
    data = pickle.load(f)

Hamiltonian = data["my_variable"]
print(Hamiltonian)

!pip install qiskit-algorithms
!pip install qiskit-aer

pip install 'qiskit[visualization]'

pip install qiskit-ibm-runtime



"""##Iteration 1

"""

from qiskit.quantum_info import SparsePauliOp
from qiskit_algorithms.minimum_eigensolvers import SamplingVQE
from qiskit_algorithms.optimizers import SLSQP
from qiskit.circuit.library import TwoLocal
from qiskit.circuit.library import EfficientSU2
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives import Estimator
from qiskit_algorithms.optimizers import COBYLA
#from qiskit.primitives import *
from qiskit.primitives import Sampler

intermediate_energies = []

def callback(eval_count, parameters, mean, std):
    intermediate_energies.append(mean)
    print(f"Iteration {eval_count}: Energy = {mean}")

print(f"Number of qubits: {Hamiltonian.num_qubits}")
sampler = Sampler()
estimator = Estimator()

optimizer = COBYLA(maxiter = 2)
#ansatz = TwoLocal(rotation_blocks=['ry', 'rz'], entanglement_blocks="cz")


ansatz = EfficientSU2(num_qubits=Hamiltonian.num_qubits, reps=1)
#optimizer = SLSQP()


vqe = SamplingVQE(sampler = sampler,ansatz=ansatz, optimizer=optimizer,callback = callback)
result = vqe.compute_minimum_eigenvalue(operator=Hamiltonian)



print(result)

print(intermediate_energies)

import matplotlib.pyplot as plt

def plot_energy_iterations(energies):

    plt.figure(figsize=(10, 6))
    plt.plot(range(1, len(energies) + 1), energies, marker='o', linestyle='-', color='b')
    plt.xlabel("Iteration")
    plt.ylabel("Energy")
    plt.title("Energy vs. Iteration")
    plt.grid(True)
    plt.show()

plot_energy_iterations(intermediate_energies)

"""## Getting the results"""

from qiskit.quantum_info import SparsePauliOp
from qiskit_algorithms.minimum_eigensolvers import SamplingVQE
from qiskit_algorithms.optimizers import SLSQP
from qiskit.circuit.library import TwoLocal
from qiskit.circuit.library import EfficientSU2
from qiskit.quantum_info import SparsePauliOp
from qiskit.primitives import Estimator
from qiskit_algorithms.optimizers import COBYLA
from qiskit.primitives import Sampler,BackendSampler
from qiskit_aer import QasmSimulator,AerSimulator
from qiskit import *

intermediate_energies = [] #Storing the energies in this variable


def callback(eval_count, parameters, mean, std):
  '''
  returns the intermediate energy values and prints them out

  '''
  intermediate_energies.append(mean)
  print(f"Iteration {eval_count}: Energy = {mean}")


print(f"Number of qubits: {Hamiltonian.num_qubits}")
#simulator = QasmSimulator()
simulator = AerSimulator(method = 'matrix_product_state')#Using the AerSimulator to run
sampler = BackendSampler(simulator) #Sampler measures the qc
estimator = Estimator() #Here not used but calculates the eigenvalue
optimizer = COBYLA(maxiter=500)#Optimizer
ansatz = EfficientSU2(num_qubits=Hamiltonian.num_qubits, reps=1)#Creating a quantum circuit with random parameters
vqe = SamplingVQE(sampler = sampler,ansatz=ansatz, optimizer=optimizer, callback=callback)#Creating the vqe object
result = vqe.compute_minimum_eigenvalue(operator=Hamiltonian)#Calculating the minimum eigenvalue

import matplotlib.pyplot as plt

def plot_energy_iterations(energies):

    plt.figure(figsize=(10, 6))
    plt.plot(range(1, len(energies) + 1), energies, marker='o', linestyle='-', color='b')
    plt.xlabel("Iteration")
    plt.ylabel("Energy")
    plt.title("Energy vs. Iteration(4 bead system HPPH)")
    plt.grid(True)
    plt.show()

plot_energy_iterations(intermediate_energies)

print(result)

print